# -*- coding: utf-8 -*-
"""Transformada de HOLSERHOLDER

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hmlz8-xF9EEl-xLMbZ8ifODWs8BTNp3Z
"""

import numpy as np

A = [[2.8, 2, 2, 2.4], 
     [2, 2.8, 1.6, 2.6], 
     [2, 1.6, 1.6, 1.8],
     [2.4, 2.6, 1.8, 1.6]]
A = np.array(A)
print("A =\n", A)

def Householder(A, verbose = False):
  """
  Esta función calcula la matriz B (tridiagonal simétrica )
  a partir de la matriz A (simétrica o no, respectivamente) mediante el método
  Householder

  Args:
    A: Array bidimensional de numpy (Matriz tridiagonal simétrica)
    verbose: Booleano para mostrar o no los resultados relevantes

  Returns:
    A: Array bidimensional 
  """

  n = A.shape[0]
  In = np.identity(n)
  
  for k in range(n - 2):
    if verbose:
      print("A^({}) =\n{}".format(k + 1, A))

    s = 0
    for j in range(k + 1, n):
      s += np.power(A[j, k], 2)

    if verbose:
      print("s =", s)

    if A[k + 1, k] == 0:
      alpha = -np.sqrt(s)
    else:
      alpha = - np.sqrt(s) * A[k + 1, k] / abs(A[k + 1, k])
    beta = np.sqrt(1 / 2 * (np.power(alpha, 2) - alpha * A[k + 1, k]))

    if verbose:
      print("alpha =", alpha)
      print("beta =", beta)

    wHat = np.empty([1, n - (k + 1)])
    wHat[0, 0] = (A[k + 1, k] - alpha) / (2 * beta)    
    for j in range(k + 1, n - 1):
      wHat[0, j - k] = A[j + 1, k] / (2 * beta)

    if verbose:
      print("wHat =", wHat)

    I = np.identity(n - (k + 1))
    PHat = I - 2 * np.transpose(wHat).dot(wHat)
    if verbose:
      print("PHat =\n", PHat)

    P = In.copy()
    for i in range(k + 1, n):
      for j in range(k + 1, n):
        P[i, j] = PHat[i - (k + 1)][j - (k + 1)]
    if verbose:
      print("P =\n", P, end = "\n\n")

    

    A = P.dot(A.dot(P))

  if verbose:
    print("B =\n{}".format(A))
  return A

B = Householder(A, verbose = True)