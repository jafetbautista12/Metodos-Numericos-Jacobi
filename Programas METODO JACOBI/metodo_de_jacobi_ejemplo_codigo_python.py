# -*- coding: utf-8 -*-
"""Metodo de jacobi Ejemplo Codigo python

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DcgwDzGzPXjZlqckRxrzUP5iCC3P0kQZ

# **Programa Para encontrar solución de sistema de ecuaciones lineales por medio del metodo de jacobi**

1.   Ingresar datos desde el codigo
"""

import numpy as np
import math
import pandas as pd
import plotly.graph_objects as go

def stopCriterion(x, x0, criterion = "ABS"):
  """
  Esta función devuelve el valor según el criterio de parada

  Args: 
    x: Array unidimensional que representa el punto actual de iteración
    x0: Array unidimensional que representa el punto anterior de iteración
    criterion: String (Criterio de parada: ABS o REL)

  Returns:
    Float (error absoluto o relativo, en función de criterion)
  """

  if criterion.upper() == "ABS":
    return np.linalg.norm(x - x0)
  else:
    return np.linalg.norm(x - x0) / np.linalg.norm(x)

def radioEspectral(A):
  """
  Esta función devuelve el radio espectral de la matriz cuadrada A

  Args: 
    A: Array bidimensional de numpy (Matriz cuadrada)

  Returns:
    radio_espectral: Float (Radio espectral de A)
  """
  
  vaps = np.linalg.eigvals(A)
  radio_espectral = max(abs(vaps))

  return radio_espectral

def DLU(A):
  """
  Esta función descompone la matriz cuadrada A en la suma D + L + U
  siendo D una matriz diagonal, L una matriz triangular inferior y 
  U una matriz triangular superior

  Args: 
    A: Array bidimensional de numpy (Matriz cuadrada)

  Returns:
    (D, L, U): Tupla de 3 arrays bidimensionales de numpy 
        * D: matriz diagonal;
        * L: matriz triangular inferior; 
        * U: matriz triangular superior
  """
  n = A.shape[0]
  D = np.zeros((n, n))
  L = np.zeros((n, n))
  U = np.zeros((n, n))

  for i in range(n):
    for j in range(n):
      if i < j:
        U[i, j] = A[i, j]
      elif i > j:
        L[i, j] = A[i, j]
      else:
        D[i, j] = A[i, j]
    

  return (D, L, U)

Ab = [[22, 5, 5, 6, 5], 
     [5, 19, 3, 6, 7], 
     [5, 5, 24, 5, 8],
     [7, 7, 4, 25, 5]]
Ab = np.array(Ab)
print("Ab =\n", Ab)

def jacobi(Ab, x0, TOL = 1e-07, nmax = 100, stop = "ABS", verbose = False):
  """
  Esta función resuelve un sistema lineal Ax = b mediante el método
  de Jacobi

  Args:
    Ab: Array bidimensional de numpy (Matriz ampliada del sistema)
    x0: Array unidimensional (Valor inicial)
    TOL: Float (Tolerancia)
    nmax: Float (Número máximo de iteraciones)
    stop: String (Criterio de parada: ABS o REL)
    verbose: Booleano para mostrar o no los resultados relevantes

  Returns:
    x: Array unidimensional (Solución del sistema)
  """

  n = Ab.shape[0]
  x = np.empty(n)

  if stop.upper() not in ["ABS", "REL"]:
    print("El criterio de parada introducido no es válido")
    return

  k = 1 # Contador de iteraciones
  while k <= nmax:
    for i in range(n):
      sum = 0
      for j in range(n):
        if j != i:
          sum += Ab[i][j] * x0[j]
      x[i] = 1 / Ab[i][i] * (-sum + Ab[i][n])

    if verbose:
      print("x^({}) = {}".format(k, x))

    if stopCriterion(x, x0, criterion = stop) < TOL:
      print("Número total de iteraciones:", k)
      print("x =", x)
      return x
        
    k += 1
    x0 = x.copy()

  print("Número máximo de iteraciones alcanzado.")
  print("El método no converge.")
  return

x0 = np.array([0, 0, 0, 0])
x = jacobi(Ab, x0, 1e-07, 100, stop = "ABS", verbose = True)

